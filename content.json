[{"title":"thrift源码阅读总结","date":"2018-05-02T12:48:13.000Z","path":"2018/05/02/thrift/","text":"由于工作需要使用thrift，并且需要根据需求修改thrift源码，因此必须熟悉thrift执行的流程。以下是thrift源码阅读的总结。 thrift协议栈概述thrift是一个rpc框架，开发者可以通过thrift自带的接口定义语言（IDL）来自动生成客户端和服务端的rpc代码。thrift协议栈如下图所示： 在client和server的最顶层都是用户自定义的处理逻辑，也就是说用户只需要编写用户逻辑，就可以完成整套的rpc调用流程。用户逻辑的下一层是thrift自动生成的代码，这些代码主要用于结构化数据的解析、发送和接收，同时服务端的自动生成代码中还包含了rpc请求的转发（client的A调用转发到server A函数进行处理）。 从上面可以看出thrift的模块是分层设计的，在每一个层次可以根据业务的实际需要选择合适的实现方式。 thrift主要分为以下几种层次模块： 底层io模块，负责实际的数据传输，包括socket、文件或压缩数据流等。 transport层负责以字节流方式发送和接收消息，是底层io模块在thrift框架中的实现，每一个底层io模块都会有一个对于TTransport来负责thrift的字节流（byte stream）数据在该io模块上的传输。例如，TSocket对应socket传输，TFileTransport对应文件传输。 TProtocol主要负责结构化数据组装成消息，或者从消息结构中读出结构化数据。TProtocol将一个有类型的数据转化为特定类型的数据。如int32会被TBinaryProtocol编码为一个4字节数据，或TBinaryProtocol从TTransport中取出4个字节数据解码为int32。 TServer负责接收client请求，并将请求转发到processor进行处理。TServer主要任务是高效地接受client的请求，特别是高并发请求的情况下快速完成请求。 processor负责对client的请求进行响应，包括rpc请求转发，调用参数解析和用户逻辑调用，返回值写回等处理步骤。processor是服务端从thrift框架转入用户逻辑的关键流程。processor同时也负责向消息结构中写入数据或读出数据。 TServerthrift核心库提供了一个TServer抽象类。 TServer在thrift框架中的主要任务是接收client请求，并转发到某个processor上进行请求处理。针对不同的访问规模，thrift提供了不同TServer模型。thrift目前支持的server模型包括： TSimpleServer：使用阻塞io的单线程服务器，主要用于调试。 TThreadedServer：使用阻塞io的多线程服务器，每一个请求都在一个线程中处理，并发访问情况下会有很多线程同时运行。 TThreadPoolServer：使用阻塞io的多线程服务器，使用线程池管理处理线程。 TNonBlockingServer：使用非阻塞io的多线程服务器，使用少量线程既可以完成大并发量的请求响应，必须使用TFramedTransport。 TServer对象通常如下工作： 使用TServerTransport获得一个TTransport。 使用TTransportFactory，可选地将原始传输转换为一个合适的应用传输。 调用TProtocolFactory，为TTransport创建一个输入和输出。 调用TProcessor对象的process方法。 TTransportTTransport是与底层数据传输紧密相关的传输层。每一种支持的底层传输方式都存在一个与之对应的TTransport。在这一层，数据是按字节流处理的，即传输层看到的是一个又一个的字节，并把这些字节按顺序发送和接收。TTransport并不了解它所传输的数据是什么类型，实际上传输层也不关心数据是什么类型，只需要按照字节方式对数据进行发送和接收即可。数据类型的解析在TProtocol这一层完成。 TTransport具体的有以下几个类： TSocket：使用阻塞的TCP socket进行数据传输，也是最常见的模式。 THttpTransport：采用http传输协议进行数据传输。 TFileTransport：文件（日志）传输类，允许client将文件传给server，允许server将收到的数据写到文件中。 TZlibTransport：与其他transport配合使用，压缩后对数据进行传输，或者将收到的数据解压。 TProtocolTProtocol的主要任务是把TTransport中的字节流转换为数据流。在TProtocol这一层就会出现具有数据类型的数据，如整型、浮点数、字符串和结构体等。TProtocol中数据虽然有了数据类型，但TProtocol只会按照指定类型将数据读出和写入，而对于数据的真正用途，需要在thrift自动生成的server和client中处理。 thrift可以让用户选择客户端与服务端之间传输通信协议的类别，在传输协议上总体划分为文本和二进制传输协议，以节约带宽，提高传输效率，一般情况下使用二进制类型的传输协议为大多数。常用协议有以下几种： TBinaryProtocl：二进制编码格式 TCompactProtocol：高效率的、密集的二进制编码格式 TJSONProtocol：使用JSON的数据编码协议进行数据传输 TSimpleJSONProtocol：提供JSON只写协议，生成的文件很容易通过脚本语言解析 TDebugProtocol：简单易懂的文本格式，以便于debug TProcessor\bTProcessor主要对TServer中一次请求的inputProtocol和outputProtocol进行操作，也就是从inputProtocol中读出client的请求数据，向outputProtocol写入用户逻辑的返回值。TProcessorprocess是一个非常关键的处理函数，因为client所有的rpc调用都会经过该函数处理并转发。 TProcessor对一次rpc调用的处理流程可以概括为： TServer接收到rpc请求之后，调用TProcessorprocess进行处理。 TProcessorprocess首先调用TTransport.readMessageBegin接口，读出rpc调用的名称和rpc调用类型。如果rpc调用类型是rpc call，则调用TProcessor.process_fn继续处理，对于未知的rpc调用类型，则抛出异常。 TProcessor.process_fn根据rpc调用名称，到自己的processMap中查找对应的rpc处理函数。如果存在对应的rpc处理函数，则调用该处理函数继续进行请求响应。不存在则抛出异常。 而rpc处理函数是rpc请求的最终步骤，主要有以下三个过程： 调用rpc请求参数的解析类，从TProtocol中读入数据完成参数解析。不管rpc调用的参数有多少个，thrift都会将参数放到一个结构体中。thrift会检查读出参数的字段id和字段类型是否与要求的参数匹配。对于不符合要求的参数都会跳过。这样，rpc接口发生变化之后，旧的处理函数在不做修改的情况下，可以通过跳过不认识的参数，来继续提供服务。 参数解析完后，调用用户逻辑，完成真正的请求响应。 用户逻辑的返回值使用返回值打包类进行打包，写入TProtocol。 ThriftClientThriftClient跟TProcessor一样主要操作inputProtocol和outputProtocol，不同的是thriftClient将rpc调用分为send和receive两个步骤： send步骤，将用户的调用参数作为一个整体的struct写入TProtocol，并发送到TServer。 send结束后，thriftClient便立即进入receive状态等待TServer的响应。对于TServer的响应，使用返回值解析类进行返回值解析，完成rpc调用。","tags":[{"name":"rpc","slug":"rpc","permalink":"http://yoursite.com/tags/rpc/"}]},{"title":"cgo的指针传递","date":"2018-03-07T12:34:25.000Z","path":"2018/03/07/cgo-pointer/","text":"在cgo的官方文档中有一小节特地介绍了cgo中传递c语言和go语言指针之间的\b传递，由于里面讲得比较抽象并且缺少例子，因此通过这篇文章\b总结cgo指针传递的注意事项。 基本概念在官方文档和本篇总结中，Go指针指的是指向Go分配的内存的指针（例如\b使用&amp;运算符或者调用new函数获取的指针）。而C指针指的是C分配的内存的指针（例如调用malloc函数获取的指针）。一个指针是Go指针还是\bC指针，是根据内存如何分配判断的，与指针的类型无关。 Go调用C传递指向Go Memory的指针 Go调用C Code时，Go传递给C Code的Go指针所指的Go Memory中不能包含任何指向Go Memory的Pointer。 值得注意的是，Go是可以传递给C Code的Go指针的，但是这个指针里面不能包含任何指向Go Memory的Pointer。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package main/*#include &lt;stdio.h&gt;struct Foo &#123; int a; int *p;&#125;;void plusOne(struct Foo *f) &#123; (f-&gt;a)++; *(f-&gt;p)++;&#125;*/import \"C\"import \"unsafe\"import \"fmt\"func main() &#123; f := &amp;C.struct_Foo&#123;&#125; f.a = 5 f.p = (*C.int)((unsafe.Pointer)(new(int))) // f.p = &amp;f.a C.plusOne(f) fmt.Println(int(f.a))&#125;``` 在以上代码可以看出，Go Code向C Code传递了一个指向Go Memory（Go分配的）指针f，但f指向的Go Memory中有一个指针p指向了另一处Go Memory:`new(int)`。当使用`go build`编译这个文件时，是可以通过编译的，然后在运行时会发生如下报错：`panic runtime error: cgo argument has Go pointer to Go pointer`### 传递指向struc field的指针&gt; Go调用C Code时，如果传递的是一个指向struct field的指针，那么“Go Memory”专指这个field所占用的内存，即便struct中有其他field指向其他Go Memory也没关系。将上面例子改为只传入指向struct field的指针。如下：```gopackage main/*#include &lt;stdio.h&gt;struct Foo &#123; int a; int *p;&#125;;void plusOne(int *i) &#123; (*i)++;&#125;*/import \"C\"import ( \"fmt\" \"unsafe\")func main() &#123; f := &amp;C.struct_Foo&#123;&#125; f.a = 5 f.p = (*C.int)((unsafe.Pointer)(new(int)) C.plusOne(&amp;f.a) fmt.Println(int(f.a))&#125; 直接指向go run，打印结果为6。可以看出，因为这次调用只传递单个field指针，指向这个field所占用的内存，而这个field也没有嵌套其他指向Go Memory的指针，因此这是符合规范的调用，不会触发panic。 传递指向slice或array中的element指针和传递struct field不同，传递一个指向slice或者array中的element指针时，需要考虑的Go Memory的范围不仅仅是这个element，而是整个array或这个slice背后的underlying array所占用的内存区域，要保证整个区域内不包含任何指向Go Memory的指针。 123456789101112131415161718192021package main/*#include &lt;stdio.h&gt;void plusOne(int **i) &#123; (**i)++;&#125;*/import \"C\"import ( \"fmt\" \"unsafe\")func main() &#123; s1 := make([]*int, 5) var a int = 5 s1[1] = &amp;a C.plusOne((**C.int)((unsafe.Pointer)(&amp;s1[0]))) fmt.Println(s1[0])&#125; 从以上代码可以看出，传递给C的是slice第一个element的地址，并不包括指向Go Memory的指针，但由于第二个element保存了另外一块Go Memory的地址（&amp;a），当运行go run时，获得报错：panic runtime error: cgo argument has Go pointer to Go pointer。 C调用Go返回指向Go分配的内存的指针 C调用的Go函数不能返回指向Go分配的内存的指针。 12345678910111213141516171819202122package main// extern int* goAdd(int, int);//// int cAdd(int a, int b) &#123;// int *i = goAdd(a, b);// return *i;// &#125;import \"C\"import \"fmt\"// export goAddfunc goAdd(a, b C.int) &#123; c := a + b return &amp;c&#125;func main() &#123; var a, b int = 5, 6 i := C.cAdd(C.int(a), C.int(b)) fmt.Println(int(i))&#125; 上面代码中，goAdd这个Go函数返回了一个指向Go分配的内存（&amp;c）的指针。运行上述代码，结果如下：panic runtime error: cgo result has Go pointer。 在C分配的内存中存储指向Go分配的内存的指针 Go Code不能在C分配的内存中存储指向Go分配的内存的指针。 12345678910111213141516171819package main// #include &lt;stdlib.h&gt;// extern void goFoo(int**);//// void cFoo() &#123;// int **p = malloc(sizeof(int*));// goFoo(p);// &#125;import \"C\"//export goFoofunc goFoo(p **C.int) &#123; *p = new(C.int)&#125;func main() &#123; C.cFoo()&#125; 针对此例，默认的GODEBUG=cgocheck=1是正常运行的，将GODEBUG=cgocheck=2则会发生报错：fatal error: Go pointer stored into non-Go memory。 检测控制以上规则会在运行时动态检测，可以通过设置GODEBUG环境变量修改检测程度，默认值是GODEBUG=cgocheck=1，可以通过设置为0取消这些检测，也可以通过设置为2来提高检测标准，但这会牺牲运行的效率。 此外，也可以通过使用unsafe包来逃脱这些限制，而且C语言方面也没法使用什么特殊的机制来限制调用Go。尽管如此，如果程序打破了上面的限制，很可能会以一种无法预料的方式调用失败。 小结cgo中，Go与C的内存应该保持着相对独立，指针之间的传递应该尽量避免嵌套不同内存的指针（如C中保存Go指针）。指针之间传递的规则不是绝对要遵守的，可以通过多种方式忽视检测，但是这往往导致无法预料的结果。","tags":[{"name":"cgo","slug":"cgo","permalink":"http://yoursite.com/tags/cgo/"}]},{"title":"go语言与c语言的相互调用","date":"2018-02-25T14:33:22.000Z","path":"2018/02/25/cgo/","text":"最近由于工作原因，需要实现go语言与c语言的相互调用。由于go语言与c语言有着千丝万缕的暧昧关系，两者之间的调用可以通过语言层面实现。下文是对此的总结。 go语言调用c语言以下为一个简短的例子：12345678910111213141516171819package main// #include &lt;stdio.h&gt;// #include &lt;stdlib.h&gt;/*void print(char *str) &#123; printf(\"%s\\n\", str);&#125;*/import \"C\"import \"unsafe\"func main() &#123; s := \"Hello Cgo\" cs := C.CString(s) C.print(cs) C.free(unsafe.pointer(cs))&#125; 与“正常”的go代码相比，上述代码有几处“特殊”的地方： 在开头的注释中出现了c语言头文件的include字样 在注释中定义了c语言函数print import了一个名为C的“包” 在main函数中调用了上述定义的c语言函数print 首先，go源码文件中的c语言代码是需要用注释包裹的，就像上面的include\b头文件以及print函数定义；其次，import “C”这个语句是必须的，而且其与上面的c代码之间不能用空行分隔，必须紧密相连。这里的”C“不是包名，而是一种类似名字空间的概念，或可以理解为伪包，c语言所有语法元素均在该伪包下面；最后，访问c语法元素时都要在其前面加上伪包前缀，比如C.uint和上面代码中的C.print、C.free等。 更详细的在go中调用c语言的用法可以参考Go与C语言的互操作，本文不再一一细述。 在上面的例子中，c语言是内嵌在go代码中的，如果代码量更大更复杂的话，这显然是很不”专业“的。那么，是否可以将c语言代码从go代码中分离出去，单独定义呢？答案是肯定的，可以通过共享库的方式实现。 cgo提供了#cgo指示符可以指定go源码在编译后与哪些共享库进行链接。例子如下： 1234567891011121314151617181920212223// hello.gopackage main// #cgo LDFLAGS: -L ./ -lhello// #include &lt;stdio.h&gt;// #include &lt;stdlib.h&gt;// #include \"hello.h\"import \"C\"func main() &#123; C.hello()&#125;// hello.c#include \"hello.h\"void hello()&#123; printf(\"hello, go\\n\");&#125;// hello.hextern void hello(); 其中在hello.go中，#cgo指示符后面添加LDFLAGS: -L ./ -lhello，作用是在go代码编译时，指定在当前目录查找so库并进行链接。 因此，只需要把hello.c编译成动态库，再编译go代码，即可在运行go代码的时候调用共享库中的c语言函数。指令如下： gcc -fPIC -o libhello.so hello.c go build -o hello ./hello c语言调用go语言与在go中调用c源码相比，在c中使用go函数的场合较少。因为一般来说，采用高级语言作为粘合剂调用低级语言能充分发挥各自的特点，而用低级语言调用高级语言反而有可能降低低级语言的性能优势，在go中，可以使用”export + 函数名“来导出go函数为c\b代码所用，看一个简单的例子： 1234567891011// hello.gopackage mainimport \"C\"import \"fmt\"// export Go2Cfunc Go2C() &#123; fmt.Println(\"hello, C\")&#125; 可通过go build的编译选项，将go代码编译成共享库以供c代码调用。注意，编译so库时必须存在main及main函数（即使main函数为空）。编译指令如下：go build -v -x -buildmode=c-shared -o libhello.so hello.go。 编译成功后，只需在c代码中引入新生成的头文件及编译时链接动态库即可实现go函数的调用。代码如下： 123456789// hello.c#include &lt;stdio.h&gt;#include \"libhello.h\"int main()&#123; Go2C(); return 0;&#125; 通过gcc -o hello -L. -lhello，即可编译成可执行程序。注意，运行前必须确定共享库运行时查找路径中存在需要链接的共享库，可通过将so库路径放到/usr/lib或者修改环境变量LD_LIBRARY_PATH。 小结go语言可以通过内嵌c代码的形式调用c语言，也可以通过调用共享库函数的方式实现；至于c语言调用go函数，则可以通过go build将go代码编译成共享库提供给c代码使用。注意，本文中的共享库均为动态共享库，至于静态共享库则未曾实验，有兴趣的可以实现一下。","tags":[{"name":"cgo","slug":"cgo","permalink":"http://yoursite.com/tags/cgo/"}]},{"title":"c与c++的相互调用","date":"2017-11-28T15:16:59.000Z","path":"2017/11/28/c-with-c++/","text":"最近项目需要使用google test\b（以下简称为gtest）作为单元测试框架，但是项目本身过于庞大，main函数无从找起，需要将gtest框架编译成静态库使用。因为项目本身是通过纯c语言编写，而gtest则是一个c++编写的测试框架，其中必然涉及c与c++之间的相互调用。注意，本文\b的\b前提是，c代码采用gcc等c语言编译器编译c代码，采用g++等c++编译\b器编译c++代码，如果c和c++代码统一使用g++编译，大部分情况是可以实现两者代码相互调用的。以下为踩坑过程的总结o_O||。 c与c++的函数区别要了解两者\b之间如何\b实现相互调用，必须先了解c与c++\b\b之间的函数有什么不同。 c++作为c语言的升级版，\b两者必然有很多不同之处。其中有一个\b重大不同点就是，c++支持函数\b重载，而c语言不支持。为\b了使函数支持重载，c++在c语言的基础上，将函数名添加上返回值和参数的类型信息。例如，int add(int, int)这个函数，通过c++\b编译器编译后，可能\b呈现的函数名为int int_add_int_int(int, int)（注：此处为大概地说明c++是如何将\b返回值和参数信息添加到函数名中的，实际中编译器不一定是这样实现的）。 从以上说明可以得出，由于c++对函数重载的支持，使得编译后的函数符号与c语言的不一致，即使是在两者函数名相同的前提下。 extern “C”的作用那么，c与c++是不能相互调用了吗？答案是否定的，因为存在着extern &quot;C&quot;这个关键字可以使语句可以按照\b类C的编译和连接规约来编译和连接，而不是C++的编译的连接规约。这样在类C的代码中就可以调用C++的函数or变量等。 注意：extern &quot;C&quot;指令中的”C”，表示的一种编译和连接规约，而不是一种语言。”C”表示符合C语言的编译和连接规约的任何语言，如Fortran、assembler等。 还有要说明的是，extern &quot;C&quot;指令仅指定编译和连接规约，但不影响语义。例如在函数声明中，指定了extern &quot;C&quot;，仍然要遵守C++的类型检测、参数转换规则。 c++中调用c代码对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字extern &quot;C&quot;，表示采用类c语言的方式解析函数符号。\b例子如下：12345678910111213141516171819202122232425262728// add.h#ifdef __ADD_H__#define __ADD_H__extern \"C\" int add(int a, int b);#endif// add.cint add(int a, int b)&#123; return a + b;&#125;// main.cc#include &lt;iostream&gt;#include \"add.h\"using namespace std;int main()&#123; cout &lt;&lt; \"1 + 1 = \" &lt;&lt; add(1, 1) &lt;&lt; endl;&#125; \b在例子中，main.cc为c++代码，add.c为c语言代码，当c++编译器识别到`extern “C”``关键字时，会去寻找add函数的实现而不是寻找类似int_add_int_int这样带参数信息的\b函数实现。 c语言调用c++代码c语言调用c++代码却并不容易，原因是c语言并不兼容c++。就算c语言可以调用c++，也会因为无法\b识别c++\b新定义的符号而\b编译报错。因此，为了实现c语言调用c++函数，必须实现以下两个步骤：1. 将c++相关函数封装为\b静态库或动态库（因为调用\b库函数时编译器并不知道里面执行的是什么\b语言）；2. 对外提供遵循类c语言规约的接口函数。例子如下所示：123456789101112131415161718192021222324252627// printNum.h#ifdef __PRINTNUM_H__#define __PRINTNUM_H__extern \"C\" void printNum(int a);#endif// printNum.cc#include &lt;iostream&gt;#include \"printNum.h\"using namespace std;void printNum(int a)&#123; cout &lt;&lt; &lt;&lt; \"num is \" &lt;&lt; a &lt;&lt; endl;&#125;// main.cextern void printNum(int a);printNum(5); 通过将cout函数封装为类c语言规约的接口函数，使得main.c中可以成功调用c++函数printNum。值得注意的是，main.c不可以直接引入printNum.h，因为c语言不能识别extern &quot;C&quot;关键字。可以利用c++预定义宏实现头文件的改写：12345678910111213#ifdef __PRINTNUM_H__#define __PRINTNUM_H__#ifdef __cplusplusextern \"C\" &#123; #endifvoid printNum(int a);#ifdef __cplusplus&#125;#endif#endif 小结小结如下： c语言与c++的相互调用可以通过extern &quot;C&quot;关键字实现 c++中调用c代码，只\b须在c++中\b\b为c代码\b函数声明\b之前加上extern &quot;C&quot; c语言调用c++代码，则需要将c\b++代码编译成静态库或动态库，然后\b对外提供\b用extern &quot;C&quot;声明的类c封装函数","tags":[{"name":"c","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"unity2d学习过程记录","date":"2017-04-17T13:16:19.000Z","path":"2017/04/17/unity2dReminder/","text":"感觉好像很久没写博客了，今天突然有点空余时间，因此前来记录一下。 最近感觉没什么事情做，自己又对独立游戏比较感兴趣，所以打算自己做一个游戏自嗨一下。然而一入游戏深似海，发现做一款游戏的坑还是很大的，需要策划、美工还有程序一起长时间协作才可能做出一个像模像样的游戏。不过我只是想做一个游戏实现一下自己的想法，因此也不必太过追求像商业化游戏那样的高质量，但是如果有机会，最好能在app store或者steam上架啦~首先，为了做一个游戏，找一个游戏引擎找了好久。一开始觉得phaserjs不错，而且自己也会用js，但是写着写着感觉单纯写代码而不和图形化界面结合，游戏效果会大打折扣，而且写出来的代码量也会很感人。接着了解到了godot，一个类似于unity的开源引擎，但是坑也是很大的，要另外学一门语言的同时，而且无论是中文还是英文，相应的参考资料少的可怜。要是踩到坑，一时半刻以我的水平真是解决不了。于是果断跳到unity的学习中，unity感觉坑虽然也有，但是已经有不少优秀游戏是通过unity制作的，而且国内外都有比较丰富的资料。于是选择unity作为游戏开发的引擎。 在学习unity过程中，遇到了不少坑，在此先记录一下，本文会随着踩到新的坑而进行更新： 本来打算使用character controller控制角色的移动，因为character controller不会像刚体那样给角色附加过多不必要的属性。但是，我在写脚本过程中发现角色的碰撞检测无法进行，发生“穿墙”现象。这个问题百度和谷歌了很多遍，而且也重新检查了代码，并没有发现什么问题。真当我不知道怎么解决的时候，突然发现，绑定的是2d碰撞器，而character controller只能检测普通的碰撞器。因此，在2d游戏中，控制角色移动还是得依靠刚体来操作。","tags":[{"name":"unity","slug":"unity","permalink":"http://yoursite.com/tags/unity/"}]},{"title":"nodejs查漏补缺","date":"2017-02-27T12:41:11.000Z","path":"2017/02/27/nodejs-reminder/","text":"Node.js逐行读取写入文件内容主要通过原生的readlineAPI实现逐行读入。示例如下： 123456789101112131415161718192021222324252627282930var readline = require('readline');var fs = require('fs');var os = require('os');var fReadName = './1.log';var fWriteName = './1.readline.log';var fRead = fs.createReadStream(fReadName);var fWrite = fs.createWriteStream(fWriteName);var objReadline = readline.createInterface(&#123; input: fRead,// 这是另一种复制方式，这样on('line')里就不必再调用fWrite.write(line)，当只是纯粹复制文件时推荐使用// 但文件末尾会多算一次index计数 sodino.com// output: fWrite, // terminal: true&#125;);var index = 1;objReadline.on('line', (line)=&gt;&#123; var tmp = 'line' + index.toString() + ':' + line; fWrite.write(tmp + os.EOL); // 下一行 console.log(index, line); index ++;&#125;);objReadline.on('close', ()=&gt;&#123; console.log('readline close...');&#125;); __dirname和./在Node.js中的区别在完成任务过程中突然想到这样一个问题，于是便探究了一番。Stack Overflow里面的答案解释得很好。主要区别在于：__dirname是运行代码所在的目录，而.则代表你在终端运行node指令所在的目录。有个例外是，当你使用.在require()方法中，.代表含有require()方法的文件的所在目录。详细例子见上文链接。 Node.js作为静态服务器最近几次任务需要从本地读取json文件，由于浏览器的跨域限制，读取本地文件往往需要搭建本地服务器（采用其他hack方法除外），参考代码如下： 123456789var http = require('http'), express = require('express'), app = express();app.use('/', express.static(__dirname));http.createServer(app).listen(3000, function() &#123; console.log('Server is running...');&#125;); 注意：该示例需要实现安装express包，在终端进入项目所在目录后，输入指令npm install express即可安装。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"正则表达式入门","date":"2017-02-25T01:51:09.000Z","path":"2017/02/25/regexp-primary/","text":"一路以来遇到正则表达式的地方都是直接去百度的，因为感觉大部分遇到的正则表达式的地方都是很常见的。这次顺便总结下正则表达式比较难记的部分，方便自己日后查阅吧(￣.￣) 正则表达式中的特殊字符感觉MDN里面的资料还是挺不错的，特此记录下里面提到过的个人感觉比较难记的部分。 ?：匹配前面一个表达式0次或者1次。等价于 {0,1}。此外，?还有一个比较重要的用途，即 如果?紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 应用 /d+/ 将会返回 “123”，如果使用 /d+?/,那么就只会匹配到 “1”。还可以运用于向前断言，如 x(?=y) 和 x(?!y) 。 (x)：捕获括号。匹配 ‘x’ 并且记住匹配项。在匹配中可以使用1、2、n表示括号中的内容，而在替换中，则使用$1、$2、$n。 (:x): 非捕获括号。匹配 ‘x’ 但是不记住匹配项。 x(?=y)：匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 x(!=y)：匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。例如，/d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’ 使用正则表达式的js方法js提供了不少使用正则表达式的方法。如RegExp的exec，和String的match、replace、search和split方法。 当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象（详见下）。如果匹配失败，那么exec方法返回null（也就是false）。 match与exec区别从前往往傻傻分不清match和exec的区别，因为两者的作用都是匹配字符串，返回数组，但是在不同情况下两者所返回的内容是不同的。 当正则表达式包含子表达式且不包含全局标志g时，二者返回相同的数组。 1234567891011// 示例：var str = 'cat10,bat20,kat30';var patten = /w(at)d+/;var arr = str.match(patten);arr[0] &lt;=&gt; ['cat10']arr[1] &lt;=&gt; ['at']var arr = patten.exec(str);arr[0] &lt;=&gt; ['cat10']arr[1] &lt;=&gt; ['at'] 当正则表达式带有全局标志g时，二者表现不一致。match会返回所有符合条件的匹配项，并以数组形式返回。数组第一项存放第一个匹配项，数组第二项存放第二个匹配项…依次类推。exec则永远返回第一个匹配项。但是当连续调用exec时，则每次的返回值都是下一个匹配项。 1234567891011121314151617181920// 示例1：var str = 'cat,bat,kat';var patten = /at/g;str.match(patten); //['at', 'at', 'at']patten.exec(str); //['at']// 示例2：var str = 'cat,bat,kat';var patten = /w+/g;str.match(patten); //['cat', 'bat', 'kat']//第一次调用patten.exec(str); //['cat']//第二次调用patten.exec(str); //['bat']//第三次调用patten.exec(str); //['kat'] 当正则表达式包含子表达式时且包含全局标志g时，二者表现不一致。match会返回所有符合条件的匹配项，并以数组形式返回。这时，match不会再返回子表达式的匹配项了。数组第一项存放第一个匹配项，数组第二项存放第二个匹配项…依次类推。exec会返回子表达式的匹配项。换句话说就是，数组第一项存放整个匹配项，数组第二项存放第一个子表达式匹配项，数组第三项存放第二个子表达式匹配项…依次类推。 12345678// 示例：var str = 'cat10,bat20,kat30';var patten = /w(at)d+/g;var arr = str.match(patten); //['cat10', 'bat20', 'kat30']var arr = patten.exec(str);arr[0] &lt;=&gt; ['cat10']arr[1] &lt;=&gt; ['at']","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"第一篇记录","date":"2017-02-24T02:46:57.000Z","path":"2017/02/24/first-blog/","text":"捣鼓了很久终于顺利地部署了这个博客，虽然网上有很多教程，但是实际操作起来也是很不一样的。 事实上，这也是我觉得要开这个博客的原因：一直以来，虽然是在努力地督促自己学习，但是感觉学的东西没有一点总结和记录，还是缺少点什么。临近毕业，也即将工作，希望这个博客能将自己一些生活学到的知识或者经历记录下来，以便日后回顾。 并不期待有多少人会浏览，只希望这个博客会成为自己的一个秘密花园，见证着自己一点点走进梦想。","tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}]}]