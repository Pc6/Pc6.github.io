[{"title":"unity2d学习过程记录","date":"2017-04-17T13:16:19.000Z","path":"2017/04/17/unity2dReminder/","text":"感觉好像很久没写博客了，今天突然有点空余时间，因此前来记录一下。 最近感觉没什么事情做，自己又对独立游戏比较感兴趣，所以打算自己做一个游戏自嗨一下。然而一入游戏深似海，发现做一款游戏的坑还是很大的，需要策划、美工还有程序一起长时间协作才可能做出一个像模像样的游戏。不过我只是想做一个游戏实现一下自己的想法，因此也不必太过追求像商业化游戏那样的高质量，但是如果有机会，最好能在app store或者steam上架啦~首先，为了做一个游戏，找一个游戏引擎找了好久。一开始觉得phaserjs不错，而且自己也会用js，但是写着写着感觉单纯写代码而不和图形化界面结合，游戏效果会大打折扣，而且写出来的代码量也会很感人。接着了解到了godot，一个类似于unity的开源引擎，但是坑也是很大的，要另外学一门语言的同时，而且无论是中文还是英文，相应的参考资料少的可怜。要是踩到坑，一时半刻以我的水平真是解决不了。于是果断跳到unity的学习中，unity感觉坑虽然也有，但是已经有不少优秀游戏是通过unity制作的，而且国内外都有比较丰富的资料。于是选择unity作为游戏开发的引擎。 在学习unity过程中，遇到了不少坑，在此先记录一下，本文会随着踩到新的坑而进行更新： 本来打算使用character controller控制角色的移动，因为character controller不会像刚体那样给角色附加过多不必要的属性。但是，我在写脚本过程中发现角色的碰撞检测无法进行，发生“穿墙”现象。这个问题百度和谷歌了很多遍，而且也重新检查了代码，并没有发现什么问题。真当我不知道怎么解决的时候，突然发现，绑定的是2d碰撞器，而character controller只能检测普通的碰撞器。因此，在2d游戏中，控制角色移动还是得依靠刚体来操作。","tags":[{"name":"unity","slug":"unity","permalink":"http://yoursite.com/tags/unity/"}]},{"title":"nodejs查漏补缺","date":"2017-02-27T12:41:11.000Z","path":"2017/02/27/nodejs-reminder/","text":"Node.js逐行读取写入文件内容主要通过原生的readlineAPI实现逐行读入。示例如下： 123456789101112131415161718192021222324252627282930var readline = require('readline');var fs = require('fs');var os = require('os');var fReadName = './1.log';var fWriteName = './1.readline.log';var fRead = fs.createReadStream(fReadName);var fWrite = fs.createWriteStream(fWriteName);var objReadline = readline.createInterface(&#123; input: fRead,// 这是另一种复制方式，这样on('line')里就不必再调用fWrite.write(line)，当只是纯粹复制文件时推荐使用// 但文件末尾会多算一次index计数 sodino.com// output: fWrite, // terminal: true&#125;);var index = 1;objReadline.on('line', (line)=&gt;&#123; var tmp = 'line' + index.toString() + ':' + line; fWrite.write(tmp + os.EOL); // 下一行 console.log(index, line); index ++;&#125;);objReadline.on('close', ()=&gt;&#123; console.log('readline close...');&#125;); __dirname和./在Node.js中的区别在完成任务过程中突然想到这样一个问题，于是便探究了一番。Stack Overflow里面的答案解释得很好。主要区别在于：__dirname是运行代码所在的目录，而.则代表你在终端运行node指令所在的目录。有个例外是，当你使用.在require()方法中，.代表含有require()方法的文件的所在目录。详细例子见上文链接。 Node.js作为静态服务器最近几次任务需要从本地读取json文件，由于浏览器的跨域限制，读取本地文件往往需要搭建本地服务器（采用其他hack方法除外），参考代码如下： 123456789var http = require('http'), express = require('express'), app = express();app.use('/', express.static(__dirname));http.createServer(app).listen(3000, function() &#123; console.log('Server is running...');&#125;); 注意：该示例需要实现安装express包，在终端进入项目所在目录后，输入指令npm install express即可安装。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"正则表达式入门","date":"2017-02-25T01:51:09.000Z","path":"2017/02/25/regexp-primary/","text":"一路以来遇到正则表达式的地方都是直接去百度的，因为感觉大部分遇到的正则表达式的地方都是很常见的。这次顺便总结下正则表达式比较难记的部分，方便自己日后查阅吧(￣.￣) 正则表达式中的特殊字符感觉MDN里面的资料还是挺不错的，特此记录下里面提到过的个人感觉比较难记的部分。 ?：匹配前面一个表达式0次或者1次。等价于 {0,1}。此外，?还有一个比较重要的用途，即 如果?紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 应用 /d+/ 将会返回 “123”，如果使用 /d+?/,那么就只会匹配到 “1”。还可以运用于向前断言，如 x(?=y) 和 x(?!y) 。 (x)：捕获括号。匹配 ‘x’ 并且记住匹配项。在匹配中可以使用1、2、n表示括号中的内容，而在替换中，则使用$1、$2、$n。 (:x): 非捕获括号。匹配 ‘x’ 但是不记住匹配项。 x(?=y)：匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 x(!=y)：匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。例如，/d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’ 使用正则表达式的js方法js提供了不少使用正则表达式的方法。如RegExp的exec，和String的match、replace、search和split方法。 当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象（详见下）。如果匹配失败，那么exec方法返回null（也就是false）。 match与exec区别从前往往傻傻分不清match和exec的区别，因为两者的作用都是匹配字符串，返回数组，但是在不同情况下两者所返回的内容是不同的。 当正则表达式包含子表达式且不包含全局标志g时，二者返回相同的数组。 1234567891011// 示例：var str = 'cat10,bat20,kat30';var patten = /w(at)d+/;var arr = str.match(patten);arr[0] &lt;=&gt; ['cat10']arr[1] &lt;=&gt; ['at']var arr = patten.exec(str);arr[0] &lt;=&gt; ['cat10']arr[1] &lt;=&gt; ['at'] 当正则表达式带有全局标志g时，二者表现不一致。match会返回所有符合条件的匹配项，并以数组形式返回。数组第一项存放第一个匹配项，数组第二项存放第二个匹配项…依次类推。exec则永远返回第一个匹配项。但是当连续调用exec时，则每次的返回值都是下一个匹配项。 1234567891011121314151617181920// 示例1：var str = 'cat,bat,kat';var patten = /at/g;str.match(patten); //['at', 'at', 'at']patten.exec(str); //['at']// 示例2：var str = 'cat,bat,kat';var patten = /w+/g;str.match(patten); //['cat', 'bat', 'kat']//第一次调用patten.exec(str); //['cat']//第二次调用patten.exec(str); //['bat']//第三次调用patten.exec(str); //['kat'] 当正则表达式包含子表达式时且包含全局标志g时，二者表现不一致。match会返回所有符合条件的匹配项，并以数组形式返回。这时，match不会再返回子表达式的匹配项了。数组第一项存放第一个匹配项，数组第二项存放第二个匹配项…依次类推。exec会返回子表达式的匹配项。换句话说就是，数组第一项存放整个匹配项，数组第二项存放第一个子表达式匹配项，数组第三项存放第二个子表达式匹配项…依次类推。 12345678// 示例：var str = 'cat10,bat20,kat30';var patten = /w(at)d+/g;var arr = str.match(patten); //['cat10', 'bat20', 'kat30']var arr = patten.exec(str);arr[0] &lt;=&gt; ['cat10']arr[1] &lt;=&gt; ['at']","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"第一篇记录","date":"2017-02-24T02:46:57.000Z","path":"2017/02/24/first-blog/","text":"捣鼓了很久终于顺利地部署了这个博客，虽然网上有很多教程，但是实际操作起来也是很不一样的。 事实上，这也是我觉得要开这个博客的原因：一直以来，虽然是在努力地督促自己学习，但是感觉学的东西没有一点总结和记录，还是缺少点什么。临近毕业，也即将工作，希望这个博客能将自己一些生活学到的知识或者经历记录下来，以便日后回顾。 并不期待有多少人会浏览，只希望这个博客会成为自己的一个秘密花园，见证着自己一点点走进梦想。","tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}]}]