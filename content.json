[{"title":"c与c++的相互调用","date":"2017-11-28T15:16:59.000Z","path":"2017/11/28/c-with-c++/","text":"最近项目需要使用google test\b（以下简称为gtest）作为单元测试框架，但是项目本身过于庞大，main函数无从找起，需要将gtest框架编译成静态库使用。因为项目本身是通过纯c语言编写，而gtest则是一个c++编写的测试框架，其中必然涉及c与c++之间的相互调用。注意，本文\b的\b前提是，c代码采用gcc等c语言编译器编译c代码，采用g++等c++编译\b器编译c++代码，如果c和c++代码统一使用g++编译，大部分情况是可以实现两者代码相互调用的。以下为踩坑过程的总结o_O||。 c与c++的函数区别要了解两者\b之间如何\b实现相互调用，必须先了解c与c++\b\b之间的函数有什么不同。 c++作为c语言的升级版，\b两者必然有很多不同之处。其中有一个\b重大不同点就是，c++支持函数\b重载，而c语言不支持。为\b了使函数支持重载，c++在c语言的基础上，将函数名添加上返回值和参数的类型信息。例如，int add(int, int)这个函数，通过c++\b编译器编译后，可能\b呈现的函数名为int int_add_int_int(int, int)（注：此处为大概地说明c++是如何将\b返回值和参数信息添加到函数名中的，实际中编译器不一定是这样实现的）。 从以上说明可以得出，由于c++对函数重载的支持，使得编译后的函数符号与c语言的不一致，即使是在两者函数名相同的前提下。 extern “C”的作用那么，c与c++是不能相互调用了吗？答案是否定的，因为存在着extern &quot;C&quot;这个关键字可以使语句可以按照\b类C的编译和连接规约来编译和连接，而不是C++的编译的连接规约。这样在类C的代码中就可以调用C++的函数or变量等。 注意：extern &quot;C&quot;指令中的”C”，表示的一种编译和连接规约，而不是一种语言。”C”表示符合C语言的编译和连接规约的任何语言，如Fortran、assembler等。 还有要说明的是，extern &quot;C&quot;指令仅指定编译和连接规约，但不影响语义。例如在函数声明中，指定了extern &quot;C&quot;，仍然要遵守C++的类型检测、参数转换规则。 c++中调用c代码对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字extern &quot;C&quot;，表示采用类c语言的方式解析函数符号。\b例子如下：12345678910111213141516171819202122232425262728// add.h#ifdef __ADD_H__#define __ADD_H__extern \"C\" int add(int a, int b);#endif// add.cint add(int a, int b)&#123; return a + b;&#125;// main.cc#include &lt;iostream&gt;#include \"add.h\"using namespace std;int main()&#123; cout &lt;&lt; \"1 + 1 = \" &lt;&lt; add(1, 1) &lt;&lt; endl;&#125; \b在例子中，main.cc为c++代码，add.c为c语言代码，当c++编译器识别到`extern “C”``关键字时，会去寻找add函数的实现而不是寻找类似int_add_int_int这样带参数信息的\b函数实现。 c语言调用c++代码c语言调用c++代码却并不容易，原因是c语言并不兼容c++。就算c语言可以调用c++，也会因为无法\b识别c++\b新定义的符号而\b编译报错。因此，为了实现c语言调用c++函数，必须实现以下两个步骤：1. 将c++相关函数封装为\b静态库或动态库（因为调用\b库函数时编译器并不知道里面执行的是什么\b语言）；2. 对外提供遵循类c语言规约的接口函数。例子如下所示：123456789101112131415161718192021222324252627// printNum.h#ifdef __PRINTNUM_H__#define __PRINTNUM_H__extern \"C\" void printNum(int a);#endif// printNum.cc#include &lt;iostream&gt;#include \"printNum.h\"using namespace std;void printNum(int a)&#123; cout &lt;&lt; &lt;&lt; \"num is \" &lt;&lt; a &lt;&lt; endl;&#125;// main.cextern void printNum(int a);printNum(5); 通过将cout函数封装为类c语言规约的接口函数，使得main.c中可以成功调用c++函数printNum。值得注意的是，main.c不可以直接引入printNum.h，因为c语言不能识别extern &quot;C&quot;关键字。可以利用c++预定义宏实现头文件的改写：12345678910111213#ifdef __PRINTNUM_H__#define __PRINTNUM_H__#ifdef __cplusplusextern \"C\" &#123; #endifvoid printNum(int a);#ifdef __cplusplus&#125;#endif#endif 小结小结如下： c语言与c++的相互调用可以通过extern &quot;C&quot;关键字实现 c++中调用c代码，只\b须在c++中\b\b为c代码\b函数声明\b之前加上extern &quot;C&quot; c语言调用c++代码，则需要将c\b++代码编译成静态库或动态库，然后\b对外提供\b用extern &quot;C&quot;声明的类c封装函数","tags":[{"name":"c","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"unity2d学习过程记录","date":"2017-04-17T13:16:19.000Z","path":"2017/04/17/unity2dReminder/","text":"感觉好像很久没写博客了，今天突然有点空余时间，因此前来记录一下。 最近感觉没什么事情做，自己又对独立游戏比较感兴趣，所以打算自己做一个游戏自嗨一下。然而一入游戏深似海，发现做一款游戏的坑还是很大的，需要策划、美工还有程序一起长时间协作才可能做出一个像模像样的游戏。不过我只是想做一个游戏实现一下自己的想法，因此也不必太过追求像商业化游戏那样的高质量，但是如果有机会，最好能在app store或者steam上架啦~首先，为了做一个游戏，找一个游戏引擎找了好久。一开始觉得phaserjs不错，而且自己也会用js，但是写着写着感觉单纯写代码而不和图形化界面结合，游戏效果会大打折扣，而且写出来的代码量也会很感人。接着了解到了godot，一个类似于unity的开源引擎，但是坑也是很大的，要另外学一门语言的同时，而且无论是中文还是英文，相应的参考资料少的可怜。要是踩到坑，一时半刻以我的水平真是解决不了。于是果断跳到unity的学习中，unity感觉坑虽然也有，但是已经有不少优秀游戏是通过unity制作的，而且国内外都有比较丰富的资料。于是选择unity作为游戏开发的引擎。 在学习unity过程中，遇到了不少坑，在此先记录一下，本文会随着踩到新的坑而进行更新： 本来打算使用character controller控制角色的移动，因为character controller不会像刚体那样给角色附加过多不必要的属性。但是，我在写脚本过程中发现角色的碰撞检测无法进行，发生“穿墙”现象。这个问题百度和谷歌了很多遍，而且也重新检查了代码，并没有发现什么问题。真当我不知道怎么解决的时候，突然发现，绑定的是2d碰撞器，而character controller只能检测普通的碰撞器。因此，在2d游戏中，控制角色移动还是得依靠刚体来操作。","tags":[{"name":"unity","slug":"unity","permalink":"http://yoursite.com/tags/unity/"}]},{"title":"nodejs查漏补缺","date":"2017-02-27T12:41:11.000Z","path":"2017/02/27/nodejs-reminder/","text":"Node.js逐行读取写入文件内容主要通过原生的readlineAPI实现逐行读入。示例如下： 123456789101112131415161718192021222324252627282930var readline = require('readline');var fs = require('fs');var os = require('os');var fReadName = './1.log';var fWriteName = './1.readline.log';var fRead = fs.createReadStream(fReadName);var fWrite = fs.createWriteStream(fWriteName);var objReadline = readline.createInterface(&#123; input: fRead,// 这是另一种复制方式，这样on('line')里就不必再调用fWrite.write(line)，当只是纯粹复制文件时推荐使用// 但文件末尾会多算一次index计数 sodino.com// output: fWrite, // terminal: true&#125;);var index = 1;objReadline.on('line', (line)=&gt;&#123; var tmp = 'line' + index.toString() + ':' + line; fWrite.write(tmp + os.EOL); // 下一行 console.log(index, line); index ++;&#125;);objReadline.on('close', ()=&gt;&#123; console.log('readline close...');&#125;); __dirname和./在Node.js中的区别在完成任务过程中突然想到这样一个问题，于是便探究了一番。Stack Overflow里面的答案解释得很好。主要区别在于：__dirname是运行代码所在的目录，而.则代表你在终端运行node指令所在的目录。有个例外是，当你使用.在require()方法中，.代表含有require()方法的文件的所在目录。详细例子见上文链接。 Node.js作为静态服务器最近几次任务需要从本地读取json文件，由于浏览器的跨域限制，读取本地文件往往需要搭建本地服务器（采用其他hack方法除外），参考代码如下： 123456789var http = require('http'), express = require('express'), app = express();app.use('/', express.static(__dirname));http.createServer(app).listen(3000, function() &#123; console.log('Server is running...');&#125;); 注意：该示例需要实现安装express包，在终端进入项目所在目录后，输入指令npm install express即可安装。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"正则表达式入门","date":"2017-02-25T01:51:09.000Z","path":"2017/02/25/regexp-primary/","text":"一路以来遇到正则表达式的地方都是直接去百度的，因为感觉大部分遇到的正则表达式的地方都是很常见的。这次顺便总结下正则表达式比较难记的部分，方便自己日后查阅吧(￣.￣) 正则表达式中的特殊字符感觉MDN里面的资料还是挺不错的，特此记录下里面提到过的个人感觉比较难记的部分。 ?：匹配前面一个表达式0次或者1次。等价于 {0,1}。此外，?还有一个比较重要的用途，即 如果?紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 应用 /d+/ 将会返回 “123”，如果使用 /d+?/,那么就只会匹配到 “1”。还可以运用于向前断言，如 x(?=y) 和 x(?!y) 。 (x)：捕获括号。匹配 ‘x’ 并且记住匹配项。在匹配中可以使用1、2、n表示括号中的内容，而在替换中，则使用$1、$2、$n。 (:x): 非捕获括号。匹配 ‘x’ 但是不记住匹配项。 x(?=y)：匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 x(!=y)：匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。例如，/d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’ 使用正则表达式的js方法js提供了不少使用正则表达式的方法。如RegExp的exec，和String的match、replace、search和split方法。 当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象（详见下）。如果匹配失败，那么exec方法返回null（也就是false）。 match与exec区别从前往往傻傻分不清match和exec的区别，因为两者的作用都是匹配字符串，返回数组，但是在不同情况下两者所返回的内容是不同的。 当正则表达式包含子表达式且不包含全局标志g时，二者返回相同的数组。 1234567891011// 示例：var str = 'cat10,bat20,kat30';var patten = /w(at)d+/;var arr = str.match(patten);arr[0] &lt;=&gt; ['cat10']arr[1] &lt;=&gt; ['at']var arr = patten.exec(str);arr[0] &lt;=&gt; ['cat10']arr[1] &lt;=&gt; ['at'] 当正则表达式带有全局标志g时，二者表现不一致。match会返回所有符合条件的匹配项，并以数组形式返回。数组第一项存放第一个匹配项，数组第二项存放第二个匹配项…依次类推。exec则永远返回第一个匹配项。但是当连续调用exec时，则每次的返回值都是下一个匹配项。 1234567891011121314151617181920// 示例1：var str = 'cat,bat,kat';var patten = /at/g;str.match(patten); //['at', 'at', 'at']patten.exec(str); //['at']// 示例2：var str = 'cat,bat,kat';var patten = /w+/g;str.match(patten); //['cat', 'bat', 'kat']//第一次调用patten.exec(str); //['cat']//第二次调用patten.exec(str); //['bat']//第三次调用patten.exec(str); //['kat'] 当正则表达式包含子表达式时且包含全局标志g时，二者表现不一致。match会返回所有符合条件的匹配项，并以数组形式返回。这时，match不会再返回子表达式的匹配项了。数组第一项存放第一个匹配项，数组第二项存放第二个匹配项…依次类推。exec会返回子表达式的匹配项。换句话说就是，数组第一项存放整个匹配项，数组第二项存放第一个子表达式匹配项，数组第三项存放第二个子表达式匹配项…依次类推。 12345678// 示例：var str = 'cat10,bat20,kat30';var patten = /w(at)d+/g;var arr = str.match(patten); //['cat10', 'bat20', 'kat30']var arr = patten.exec(str);arr[0] &lt;=&gt; ['cat10']arr[1] &lt;=&gt; ['at']","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"第一篇记录","date":"2017-02-24T02:46:57.000Z","path":"2017/02/24/first-blog/","text":"捣鼓了很久终于顺利地部署了这个博客，虽然网上有很多教程，但是实际操作起来也是很不一样的。 事实上，这也是我觉得要开这个博客的原因：一直以来，虽然是在努力地督促自己学习，但是感觉学的东西没有一点总结和记录，还是缺少点什么。临近毕业，也即将工作，希望这个博客能将自己一些生活学到的知识或者经历记录下来，以便日后回顾。 并不期待有多少人会浏览，只希望这个博客会成为自己的一个秘密花园，见证着自己一点点走进梦想。","tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}]}]